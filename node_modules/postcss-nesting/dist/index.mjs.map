{"version":3,"file":"index.mjs","sources":["../src/lib/shift-nodes-before-parent.js","../src/lib/cleanup-parent.js","../src/lib/merge-selectors.js","../src/lib/rule-within-rule.js","../src/lib/list.js","../src/lib/valid-atrules.js","../src/lib/atrule-within-atrule.js","../src/lib/merge-params.js","../src/lib/walk.js","../src/lib/nest-rule-within-rule.js","../src/lib/atrule-within-rule.js","../src/index.js"],"sourcesContent":["export default function shiftNodesBeforeParent(node) {\n\tconst parent = node.parent;\n\tconst index = parent.index(node);\n\n\t// conditionally move previous siblings into a clone of the parent\n\tif (index) {\n\t\tparent.cloneBefore().removeAll().append(parent.nodes.slice(0, index));\n\t}\n\n\t// move the current node before the parent (and after the conditional clone)\n\tparent.before(node);\n\n\treturn parent;\n}\n","export default function cleanupParent(parent) {\n\tif (!parent.nodes.length) {\n\t\tparent.remove();\n\t}\n}\n","import parser from 'postcss-selector-parser';\n\nexport default function mergeSelectors(fromSelectors, toSelectors) {\n\tlet complexFromSelector = false;\n\tlet fromSelectorIsList = fromSelectors.length > 1;\n\tconst fromSelectorAST = parser().astSync(fromSelectors.join(','));\n\tconst fromSelectorWithIsAST = parser().astSync(`:is(${fromSelectors.join(',')})`);\n\n\tlet fromSelectorCounterAST = 0;\n\tfromSelectorAST.walk((x) => {\n\t\tif (x.type === 'root') {\n\t\t\treturn;\n\t\t}\n\n\t\tfromSelectorCounterAST++;\n\t});\n\n\tif (fromSelectorCounterAST > 2) {\n\t\tcomplexFromSelector = true;\n\t}\n\n\treturn toSelectors.map((toSelector) => {\n\t\treturn parser((selectors) => {\n\t\t\tselectors.walkNesting((selector) => {\n\t\t\t\tif (fromSelectorIsList) {\n\t\t\t\t\tselector.replaceWith(fromSelectorWithIsAST.clone());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// foo &foo foo & baz -> foo &:is(foo) foo & baz\n\t\t\t\tif (\n\t\t\t\t\tselector.next() &&\n\t\t\t\t\tselector.next().type === 'tag'\n\t\t\t\t) {\n\t\t\t\t\tconst isPseudo = parser.pseudo({ value: ':is' });\n\t\t\t\t\tisPseudo.append(selector.next().clone());\n\t\t\t\t\tselector.next().replaceWith(isPseudo);\n\n\t\t\t\t\tif (complexFromSelector) {\n\t\t\t\t\t\tselector.replaceWith(fromSelectorWithIsAST.clone());\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tselector.replaceWith(fromSelectorAST.clone());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// h1 and foo can combine to fooh1|h1foo which would be a different selector.\n\t\t\t\t// h1 and .foo can combine to .fooh1 which would be a different selector.\n\t\t\t\t// h1 { .foo& {} } -> h1.foo: {}\n\t\t\t\t// h1 { foo& {} } -> foo:is(h1) {}\n\t\t\t\tif (\n\t\t\t\t\tselector.prev() &&\n\t\t\t\t\tselector.prev().type !== 'combinator' &&\n\t\t\t\t\tfromSelectorAST.first &&\n\t\t\t\t\tfromSelectorAST.first.first &&\n\t\t\t\t\tfromSelectorAST.first.first.type === 'tag'\n\t\t\t\t) {\n\t\t\t\t\tif (complexFromSelector) {\n\t\t\t\t\t\tselector.replaceWith(fromSelectorWithIsAST.clone());\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet firstPrecedingNonCombinatorNode = selector.prev();\n\t\t\t\t\twhile (firstPrecedingNonCombinatorNode.prev() && firstPrecedingNonCombinatorNode.prev().type !== 'combinator') {\n\t\t\t\t\t\tfirstPrecedingNonCombinatorNode = firstPrecedingNonCombinatorNode.prev();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (firstPrecedingNonCombinatorNode.type !== 'tag') {\n\t\t\t\t\t\t// Safe to just prepend the parent selector.\n\t\t\t\t\t\t// h1 { .foo& {} } -> h1.foo: {}\n\t\t\t\t\t\tselector.parent.insertBefore(firstPrecedingNonCombinatorNode, fromSelectorAST.clone());\n\t\t\t\t\t\tselector.remove();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unsafe -> wrapping the parent selector in :is().\n\t\t\t\t\t// h1 { foo& {} } -> foo:is(h1) {}\n\t\t\t\t\tconst isPseudo = parser.pseudo({ value: ':is' });\n\t\t\t\t\tisPseudo.append(fromSelectorAST.clone());\n\t\t\t\t\tselector.replaceWith(isPseudo);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tselector.replaceWith(fromSelectorAST.clone());\n\t\t\t});\n\t\t}).processSync(toSelector);\n\t});\n}\n","import shiftNodesBeforeParent from './shift-nodes-before-parent.js';\nimport cleanupParent from './cleanup-parent.js';\nimport mergeSelectors from './merge-selectors.js';\n\nexport default function transformRuleWithinRule(node) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node);\n\n\t// update the selectors of the node to be merged with the parent\n\tnode.selectors = mergeSelectors(parent.selectors, node.selectors);\n\n\t// merge similar rules back together\n\tconst areSameRule = (node.type === 'rule' && parent.type === 'rule' && node.selector === parent.selector) || (node.type === 'atrule' && parent.type === 'atrule' && node.params === parent.params);\n\n\tif (areSameRule) {\n\t\tnode.append(...parent.nodes);\n\t}\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent);\n}\n\nexport const isRuleWithinRule = (node) => node.type === 'rule' && Object(node.parent).type === 'rule' && node.selectors.every((selector) => selector.trim().indexOf('&') === 0 && selector.indexOf('|') === -1);\n","export const comma = (string) => {\n\tlet array = [];\n\tlet current = '';\n\tlet split = false;\n\n\tlet func = 0;\n\tlet quote = false;\n\tlet escape = false;\n\n\tfor (let letter of string) {\n\t\tif (escape) {\n\t\t\tescape = false;\n\t\t} else if (letter === '\\\\') {\n\t\t\tescape = true;\n\t\t} else if (quote) {\n\t\t\tif (letter === quote) {\n\t\t\t\tquote = false;\n\t\t\t}\n\t\t} else if (letter === '\"' || letter === '\\'') {\n\t\t\tquote = letter;\n\t\t} else if (letter === '(') {\n\t\t\tfunc += 1;\n\t\t} else if (letter === ')') {\n\t\t\tif (func > 0) func -= 1;\n\t\t} else if (func === 0) {\n\t\t\tif (letter === ',') split = true;\n\t\t}\n\n\t\tif (split) {\n\t\t\tif (current !== '') array.push(current.trim());\n\t\t\tcurrent = '';\n\t\t\tsplit = false;\n\t\t} else {\n\t\t\tcurrent += letter;\n\t\t}\n\t}\n\n\tarray.push(current.trim());\n\treturn array;\n};\n","export default ['container', 'document', 'media', 'supports'];\n","import cleanupParent from './cleanup-parent.js';\nimport mergeParams from './merge-params.js';\nimport shiftNodesBeforeParent from './shift-nodes-before-parent.js';\nimport validAtrules from './valid-atrules.js';\n\n/*\n * DEPRECATED: In v7.0.0 these features will be removed as they are not part of\n * the nesting proposal.\n */\n\nexport default function transformAtruleWithinAtrule(node) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node);\n\n\t// update the params of the node to be merged with the parent\n\tnode.params = mergeParams(parent.params, node.params);\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent);\n}\n\nexport const isAtruleWithinAtrule = (node) => node.type === 'atrule' && validAtrules.includes(node.name) && Object(node.parent).type === 'atrule' && node.name === node.parent.name;\n","import { comma } from './list.js';\n\nexport default function mergeParams(fromParams, toParams) {\n\treturn comma(fromParams)\n\t\t.map((params1) =>\n\t\t\tcomma(toParams)\n\t\t\t\t.map((params2) => `${params1} and ${params2}`)\n\t\t\t\t.join(', '),\n\t\t)\n\t\t.join(', ');\n}\n","import transformRuleWithinRule, { isRuleWithinRule } from './rule-within-rule.js';\nimport transformNestRuleWithinRule, { isNestRuleWithinRule } from './nest-rule-within-rule.js';\nimport transformAtruleWithinRule, { isAtruleWithinRule } from './atrule-within-rule.js';\nimport transformAtruleWithinAtrule, { isAtruleWithinAtrule } from './atrule-within-atrule.js';\n\nexport default function walk(node) {\n\tnode.each((child) => {\n\t\tif (isRuleWithinRule(child)) {\n\t\t\ttransformRuleWithinRule(child);\n\t\t} else if (isNestRuleWithinRule(child)) {\n\t\t\ttransformNestRuleWithinRule(child, walk);\n\t\t} else if (isAtruleWithinRule(child)) {\n\t\t\ttransformAtruleWithinRule(child, walk);\n\t\t} else if (isAtruleWithinAtrule(child)) {\n\t\t\ttransformAtruleWithinAtrule(child);\n\t\t}\n\n\t\tif (Object(child.nodes).length) {\n\t\t\twalk(child);\n\t\t}\n\t});\n}\n","import { comma } from './list.js';\nimport shiftNodesBeforeParent from './shift-nodes-before-parent.js';\nimport cleanupParent from './cleanup-parent.js';\nimport mergeSelectors from './merge-selectors.js';\n\nexport default function transformNestRuleWithinRule(node, walk) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node);\n\n\t// clone the parent as a new rule with children appended to it\n\tconst rule = parent.clone().removeAll().append(node.nodes);\n\n\t// replace the node with the new rule\n\tnode.replaceWith(rule);\n\n\t// update the selectors of the node to be merged with the parent\n\trule.selectors = mergeSelectors(parent.selectors, comma(node.params));\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent);\n\n\t// walk the children of the new rule\n\twalk(rule);\n}\n\nexport const isNestRuleWithinRule = (node) => node.type === 'atrule' && node.name === 'nest' && Object(node.parent).type === 'rule' && comma(node.params).every((selector) => selector.split('&').length >= 2 && selector.indexOf('|') === -1);\n","import cleanupParent from './cleanup-parent.js';\nimport shiftNodesBeforeParent from './shift-nodes-before-parent.js';\nimport validAtrules from './valid-atrules.js';\n\nexport default function atruleWithinRule(node, walk) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node);\n\n\t// clone the parent as a new rule with children appended to it\n\tconst rule = parent.clone().removeAll().append(node.nodes);\n\n\t// append the new rule to the node\n\tnode.append(rule);\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent);\n\n\t// walk the children of the new rule\n\twalk(rule);\n}\n\nexport const isAtruleWithinRule = (node) => node.type === 'atrule' && validAtrules.includes(node.name) && Object(node.parent).type === 'rule';\n","import walk from './lib/walk.js';\n\n/**\n * @returns {import('postcss').Plugin}\n */\nexport default function postcssNesting() {\n\treturn {\n\t\tpostcssPlugin: 'postcss-nesting',\n\t\tRule(rule) {\n\t\t\twalk(rule);\n\t\t},\n\t};\n}\n\npostcssNesting.postcss = true;\n"],"names":["shiftNodesBeforeParent","node","parent","index","cloneBefore","removeAll","append","nodes","slice","before","cleanupParent","length","remove","mergeSelectors","fromSelectors","toSelectors","complexFromSelector","fromSelectorIsList","fromSelectorAST","parser","astSync","join","fromSelectorWithIsAST","fromSelectorCounterAST","walk","x","type","map","toSelector","selectors","walkNesting","selector","replaceWith","clone","next","isPseudo","pseudo","value","prev","first","firstPrecedingNonCombinatorNode","insertBefore","processSync","comma","string","array","current","split","func","quote","escape","letter","push","trim","transformAtruleWithinAtrule","fromParams","toParams","params","params1","params2","each","child","Object","every","indexOf","isRuleWithinRule","transformRuleWithinRule","name","isNestRuleWithinRule","rule","transformNestRuleWithinRule","validAtrules","includes","isAtruleWithinRule","transformAtruleWithinRule","isAtruleWithinAtrule","postcssNesting","postcssPlugin","Rule","postcss"],"mappings":"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"}